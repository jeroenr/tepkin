{"name":"Tepkin","tagline":"Reactive MongoDB Driver for Scala","body":"# Tepkin\r\n\r\nReactive MongoDB Driver for Scala built on top of Akka IO and Akka Streams.\r\n\r\n[![Join the chat at https://gitter.im/jeroenr/tepkin](https://badges.gitter.im/jeroenr/tepkin.svg)](https://gitter.im/jeroenr/tepkin?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n[![Build Status](https://travis-ci.org/jeroenr/tepkin.svg?branch=master)](https://travis-ci.org/jeroenr/tepkin)\r\n[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.github.jeroenr/tepkin_2.11/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.jeroenr/tepkin_2.11)\r\n[![License](https://img.shields.io/hexpm/l/plug.svg)](http://www.apache.org/licenses/LICENSE-2.0)\r\n\r\nOnly MongoDB 2.6+, Scala 2.11+ is supported.\r\n\r\n## Contributions\r\nTepkin is a young but very active project and absolutely needs your help. Good ways to contribute include:\r\n\r\n* Raising bugs and feature requests\r\n* Fixing bugs\r\n* Improving the performance\r\n* Adding to the documentation\r\n\r\n## Quick Start\r\n\r\n### Setting up dependencies\r\n\r\nLatest stable Tepkin release is **0.6** and is available on [Maven Central](http://search.maven.org/#search%7Cga%7C1%7Ctepkin). Just add the following dependency:\r\n\r\n```scala\r\nlibraryDependencies ++= Seq(\r\n  \"com.github.jeroenr\" %% \"tepkin\" % \"0.6\"\r\n)\r\n```\r\n\r\nOr if you want to be on the bleeding edge using snapshots, latest snapshot release is **0.7-SNAPSHOT**. Add the following repository and dependency:\r\n```scala\r\nresolvers += \"Sonatype Snapshots\" at \"https://oss.sonatype.org/content/repositories/snapshots/\"\r\n\r\nlibraryDependencies ++= Seq(\r\n  \"com.github.jeroenr\" %% \"tepkin\" % \"0.7-SNAPSHOT\"\r\n)\r\n```\r\n\r\n## Scala API\r\n\r\n### Working with BSON DSL\r\n\r\nTo construct a Bson document, you can either create BsonElements and join them with `~` or create a document directly.\r\n\r\n```scala\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\nimport com.github.jeroenr.bson.element.BsonObjectId\r\nimport org.joda.time.DateTime\r\n\r\n// Construct a BsonDocument from BsonElements\r\nval element = \"name\" := \"Johny\"\r\nval document = element ~\r\n  (\"surname\" := \"Doe\") ~\r\n  (\"age\" := 28) ~\r\n  (\"months\" := $array(1, 2, 3))\r\n\r\n// Construct a BsonDocument\r\nval document = $document(\r\n  \"_id\" := BsonObjectId.generate,\r\n  \"name\" := \"Johny\",\r\n  \"surname\" := \"Doe\",\r\n  \"age\" := 28,\r\n  \"months\" := $array(1, 2, 3),\r\n  \"details\" := $document(\r\n    \"salary\" := 455.5,\r\n    \"inventory\" := $array(\"a\", 3.5, 1L, true),\r\n    \"birthday\" := new DateTime(1987, 3, 5, 0, 0)\r\n  )\r\n)\r\n```\r\n\r\nThere is an implicit conversion from any `BsonElement` to `BsonDocument` for convenience.\r\n\r\n```scala\r\nimport com.github.jeroenr.bson.BsonDocument\r\nimport com.github.jeroenr.bson.element.BsonElement\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\n\r\nval element: BsonElement = \"name\" := \"fehmi\"\r\nval document: BsonDocument = \"name\" := \"fehmi\"\r\n```\r\n\r\n### Connecting to MongoDB\r\n\r\nTo make a connection to MongoDB, use the `MongoClient` interface.\r\n\r\n```scala\r\nimport com.github.jeroenr.tepkin.MongoClient\r\n\r\n// Connect to a MongoDB node.\r\nval client = MongoClient(\"mongodb://localhost\")\r\n```\r\n\r\n`MongoClient` manages multiple connection pools to MongoDB instances and therefore is a heavy class. Most of the time you will need only one `MongoClient` instance per application.\r\n\r\nUse `MongoDatabase` and `MongoCollection` in order to obtain a reference to a database and a collection.\r\n\r\n```scala\r\n// Obtain a reference to the \"tepkin\" database\r\nval db = client(\"tepkin\")\r\n\r\n// Obtain a reference to the \"example\" collection in \"tepkin\" database.\r\nval collection = db(\"example\")\r\n```\r\n\r\n`MongoDatabase` and `MongoCollection` are lightweight classes and may be instantiated more than once if needed. However they are both immutable and reusable.\r\n\r\nAll methods in the `MongoCollection` class need an implicit `scala.concurrent.ExecutionContext` and an `akka.util.Timeout`. You can define a default timeout and use the client's execution context as shown below:\r\n\r\n```scala\r\nimport akka.util.Timeout\r\nimport scala.concurrent.duration._\r\n\r\n// val client = ...\r\n\r\nimport client.ec\r\nimplicit val timeout: Timeout = 5.seconds\r\n```\r\n\r\n### Find documents\r\n\r\n```scala\r\nimport com.github.jeroenr.bson.BsonDocument\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\n\r\nval query: BsonDocument = \"name\" := \"fehmi\"\r\n\r\nval source = collection.find(query)\r\n```\r\n\r\nAll find methods in Tepkin return an `akka.stream.scaladsl.Source[List[BsonDocument], ActorRef]`. Then you can use any method in Akka Streams to process the returned stream.\r\n\r\n### Insert operations\r\n\r\n#### Insert a single document\r\n\r\n```scala\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\n\r\nval document = (\"name\" := \"fehmi\") ~ (\"surname\" := \"saglam\")\r\ncollection.insert(document)\r\n```\r\n#### Insert a collection of documents\r\n\r\n```scala\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\n\r\nval documents = (1 to 100).map(i => $document(\"name\" := s\"fehmi$i\"))\r\ncollection.insert(documents)\r\n```\r\n#### Insert a large number of documents from a stream\r\n\r\n```scala\r\nimport akka.stream.ActorFlowMaterializer\r\nimport akka.stream.scaladsl.Source\r\nimport com.github.jeroenr.bson.BsonDocument\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\n\r\nimport scala.collection.immutable.Iterable\r\n\r\nimplicit val mat = ActorFlowMaterializer()(client.context)\r\n\r\nval documents: Source[List[BsonDocument], akka.NotUsed] = Source {\r\n  Iterable.tabulate(100) { _ =>\r\n    (1 to 1000).map(i => $document(\"name\" := s\"fehmi$i\")).toList\r\n  }\r\n}\r\n\r\ncollection.insertFromSource(documents).runForeach(_ => ())\r\n```\r\n### Other queries\r\n\r\n#### Update\r\n\r\n```scala\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\n\r\nimport scala.concurrent.Future\r\n\r\nval document = (\"name\" := \"fehmi\") ~ (\"surname\" := \"saglam\")\r\n\r\nval result: Future[UpdateResult] = for {\r\n  insert <- collection.insert(document)\r\n  update <- collection.update(\r\n    query = \"name\" := \"fehmi\",\r\n    update = $set(\"name\" := \"fehmi can\")\r\n  )\r\n} yield update\r\n```\r\n\r\n#### Find and update\r\n\r\nUpdate and return the old document.\r\n\r\n```scala\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\n\r\ncollection.findAndUpdate(\r\n  query = Some(\"name\" := \"fehmi\"),\r\n  update = $set(\"name\" := \"fehmi can\")\r\n)\r\n```\r\n\r\nUpdate and return the updated document.\r\n\r\n```scala\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\n\r\ncollection.findAndUpdate(\r\n  query = Some(\"name\" := \"fehmi\"),\r\n  update = $set(\"name\" := \"fehmi can\"),\r\n  returnNew = true\r\n)\r\n```\r\n\r\n#### Create index\r\n```scala\r\nimport com.github.jeroenr.bson.BsonDsl._\r\nimport com.github.jeroenr.bson.Implicits._\r\nimport com.github.jeroenr.tepkin.protocol.command.Index\r\n\r\ncollection.createIndexes(Index(name = \"name_surname\", key = (\"name\" := 1) ~ (\"surname\" := 1)))\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}